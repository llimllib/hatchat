package models

// Code generated by dbtpl. DO NOT EDIT.

import (
	"context"
)

// RoomMessagesWithCursor represents a row from 'room_messages_with_cursor'.
type RoomMessagesWithCursor struct {
	ID         string `json:"id"`          // id
	RoomID     string `json:"room_id"`     // room_id
	UserID     string `json:"user_id"`     // user_id
	Body       string `json:"body"`        // body
	CreatedAt  string `json:"created_at"`  // created_at
	ModifiedAt string `json:"modified_at"` // modified_at
	Username   string `json:"username"`    // username
}

// RoomMessagesWithCursorsByRoomIDCursorLimit runs a custom query, returning results as [RoomMessagesWithCursor].
func RoomMessagesWithCursorsByRoomIDCursorLimit(ctx context.Context, db DB, roomID, cursor string, limit int) ([]*RoomMessagesWithCursor, error) {
	// query
	const sqlstr = `SELECT m.id, m.room_id, m.user_id, m.body, m.created_at, m.modified_at, u.username ` +
		`FROM messages m ` +
		`JOIN users u ON m.user_id = u.id ` +
		`WHERE m.room_id = $1 AND m.created_at < $2 ` +
		`ORDER BY m.created_at DESC ` +
		`LIMIT $3`
	// run
	logf(sqlstr, roomID, cursor, limit)
	rows, err := db.QueryContext(ctx, sqlstr, roomID, cursor, limit)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// load results
	var res []*RoomMessagesWithCursor
	for rows.Next() {
		var rmwc RoomMessagesWithCursor
		// scan
		if err := rows.Scan(&rmwc.ID, &rmwc.RoomID, &rmwc.UserID, &rmwc.Body, &rmwc.CreatedAt, &rmwc.ModifiedAt, &rmwc.Username); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &rmwc)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}
