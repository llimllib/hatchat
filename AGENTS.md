# Hatchat - Agent Guidelines

## Project Overview

Hatchat is a Slack-like chat application built with Go (backend) and vanilla TypeScript (frontend), using SQLite for persistence and WebSockets for real-time communication.

## Architecture

```
hatchat/
├── cmd/server.go          # Entry point, CLI flag parsing
├── server/
│   ├── server.go          # HTTP server setup, routes, auth handlers
│   ├── hub.go             # WebSocket hub - manages connected clients
│   ├── client.go          # WebSocket client - per-connection handler
│   ├── api/               # WebSocket message handlers
│   │   ├── api.go         # Api struct, Envelope type
│   │   ├── init.go        # Handle "init" messages
│   │   ├── message.go     # Handle "message" messages
│   │   └── error.go       # Error response helper
│   ├── apimodels/         # Types exposed to clients (JSON serialization)
│   ├── models/            # Database models (generated by xo)
│   ├── db/                # Database connection wrapper
│   └── middleware/        # HTTP middleware (auth, logging, panic recovery)
├── client/
│   └── src/index.ts       # Frontend TypeScript source
├── static/                # Compiled JS, CSS
├── template/              # HTML templates
├── schema.sql             # Database schema (source of truth)
└── tools/models.sh        # Regenerates models from schema
```

## Technology Stack

- **Backend**: Go 1.21+, standard library `net/http`, `log/slog` for logging
- **Database**: SQLite with WAL mode, separate read/write connections
- **ORM**: [xo](https://github.com/xo/xo) for model generation from schema
- **WebSockets**: gorilla/websocket
- **Frontend**: Vanilla TypeScript, esbuild for bundling
- **Password hashing**: bcrypt via `golang.org/x/crypto`

## Coding Patterns

### Backend

#### HTTP Handlers

- Handlers are methods on `*ChatServer` struct
- Use the middleware chain: `h.middleware(route, handler)` which applies panic recovery, request ID, and request logging
- Auth-protected routes wrap handler with `authRequired()`
- Return early on errors with appropriate redirects or HTTP error codes

#### WebSocket Message Protocol

Messages use an envelope pattern:

```go
type Envelope struct {
    Type string  // Message type: "init", "message", "error", etc.
    Data any     // Type-specific payload
}
```

Client sends JSON like:

```json
{ "type": "message", "data": { "body": "hello", "room_id": "roo_abc123" } }
```

Server responds with same envelope structure.

#### Database Models

- **DO NOT edit `*.xo.go` files** - they are generated
- Schema changes go in `schema.sql`
- Run `just models` (or `bash tools/models.sh`) to regenerate
- Custom queries can be added to `tools/models.sh` using xo's query mode
- Manual model extensions go in separate files (e.g., `generate_id.go`)

#### ID Generation

All IDs are prefixed strings for debuggability:

- Users: `usr_` + 16 hex chars
- Rooms: `roo_` + 12 hex chars
- Messages: `msg_` + 12 hex chars
- Sessions: base64-encoded random bytes

#### Database Access

- Use `db.QueryContext` / `db.QueryRowContext` for reads (uses read connection)
- Use `db.ExecContext` for writes (uses write connection with mutex)
- Always pass `context.Context` as first argument
- Timestamps stored as RFC3339 strings

#### Error Handling

- Use structured logging: `logger.Error("message", "key", value, "err", err)`
- Don't expose internal errors to clients
- Middleware recovers from panics and returns 500

#### Separation of Concerns

- `models/` - Database representation, generated code
- `apimodels/` - Client-facing types, conversion from models
- `api/` - WebSocket message handling logic

### Frontend

#### DOM Helpers

Custom `$()` function for element creation:

```typescript
$(
  "div",
  { class: "message" },
  $("span", { text: username }),
  text(": "),
  $("span", { text: messageBody }),
);
```

#### WebSocket Client

- Single `Client` class manages WebSocket connection
- Messages are JSON with `{type, data}` structure
- Optimistic UI updates (show message immediately, don't wait for server)

#### Future Direction

- Keep close to web platform (Web Components when needed)
- Avoid frameworks; use modern browser APIs
- Prioritize backend API quality for alternative client support

## Development Workflow

### Running the Server

```bash
just run          # Build and run
modd              # Auto-rebuild on changes (install: go install github.com/cortesi/modd/cmd/modd)
```

### Building

```bash
just build        # Build both Go and JS
just build-go     # Go only
just build-js     # TypeScript only
```

### Database

```bash
just models       # Regenerate models from schema.sql
just browse-db    # Open database in Datasette
```

### Testing & Linting

```bash
just test         # Run linter and tests
just lint         # Linter only
```

**Important**: `just lint` must pass before reporting work as complete. Fix all linting errors before finishing a task.

## Key Design Decisions

1. **Single workspace**: No multi-tenancy; one deployment = one workspace
2. **SQLite**: Simple deployment, good enough for moderate scale
3. **Session-based auth**: Cookie-based sessions, no JWT
4. **Room-based access**: Users must be members of a room to see messages
5. **Real-time first**: WebSocket is primary API; REST/HTTP for auth only

## Adding New Features

### Adding a New WebSocket Message Type

1. Add handler in `server/api/`:

```go
func (a *Api) NewMessageType(user *models.User, msg json.RawMessage) ([]byte, error) {
    // Parse msg, validate, perform action, return response
}
```

2. Add case in `client.go` `readPump()` switch statement

3. Add client-side handler in `client/src/index.ts`

### Adding a New Database Table

1. Add table definition to `schema.sql`
2. Run `just models`
3. Add any custom queries to `tools/models.sh` if needed
4. Create apimodels types if exposing to clients

### Adding a New HTTP Endpoint

1. Add handler method to `ChatServer` in `server/server.go`
2. Register route in `Run()` with appropriate middleware
3. Use `authRequired()` wrapper if authentication needed
