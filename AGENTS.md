# Hatchat - Agent Guidelines

## Project Overview

Hatchat is a Slack-like chat application built with Go (backend) and vanilla TypeScript (frontend), using SQLite for persistence and WebSockets for real-time communication.

## Architecture

```
hatchat/
├── cmd/server.go          # Entry point, CLI flag parsing
├── server/
│   ├── server.go          # HTTP server setup, routes, auth handlers
│   ├── hub.go             # WebSocket hub - manages connected clients
│   ├── client.go          # WebSocket client - per-connection handler
│   ├── api/               # WebSocket message handlers
│   │   ├── api.go         # Api struct, Envelope type alias
│   │   ├── init.go        # Handle "init" messages
│   │   ├── message.go     # Handle "message" messages
│   │   ├── history.go     # Handle "history" messages (message history)
│   │   └── error.go       # Error response helper
│   ├── protocol/          # WebSocket protocol type definitions (source of truth)
│   ├── models/            # Database models (generated by dbtpl) - DO NOT EDIT
│   ├── db/                # Database connection wrapper + custom query functions
│   └── middleware/        # HTTP middleware (auth, logging, panic recovery)
├── client/
│   ├── src/
│   │   ├── index.ts               # Frontend TypeScript source
│   │   ├── types.ts               # Re-exports protocol types + client-only types
│   │   └── protocol.generated.ts  # Generated types - DO NOT EDIT
│   └── gen-types.mjs      # Script to generate TS from schema
├── e2e/                   # End-to-end tests (Playwright)
│   ├── tests/
│   │   ├── helpers.ts     # Test utilities (login, sendMessage, etc.)
│   │   ├── auth.spec.ts   # Authentication tests
│   │   ├── messaging.spec.ts # Real-time messaging tests
│   │   └── rooms.spec.ts  # Room switching and scoping tests
│   └── playwright.config.ts
├── schema/
│   └── protocol.json      # Generated JSON Schema - DO NOT EDIT
├── docs/
│   ├── template.html      # Pandoc template for site generation
│   └── site/              # Generated documentation website - DO NOT EDIT
├── static/                # Compiled JS, CSS
├── template/              # HTML templates
├── schema.sql             # Database schema (source of truth)
├── tools/
│   ├── models.sh          # Regenerates DB models from schema
│   └── schemagen/         # Tool to generate JSON Schema from protocol types
├── requirements.txt       # Python dependencies (for doc generation)
└── justfile               # Build commands
```

## Technology Stack

- **Backend**: Go 1.25+, standard library `net/http`, `log/slog` for logging
- **Database**: SQLite with WAL mode, separate read/write connections
- **ORM**: [dbtpl](https://github.com/xo/dbtpl) (formerly xo) for model generation from schema
- **WebSockets**: gorilla/websocket
- **Frontend**: Vanilla TypeScript, esbuild for bundling, Zod for runtime validation
- **Password hashing**: bcrypt via `golang.org/x/crypto`

## Coding Patterns

### Backend

#### HTTP Handlers

- Handlers are methods on `*ChatServer` struct
- Use the middleware chain: `h.middleware(route, handler)` which applies panic recovery, request ID, and request logging
- Auth-protected routes wrap handler with `authRequired()`
- Return early on errors with appropriate redirects or HTTP error codes

#### WebSocket Message Protocol

Messages use an envelope pattern:

```go
type Envelope struct {
    Type string  // Message type: "init", "message", "history", "error", etc.
    Data any     // Type-specific payload
}
```

Client sends JSON like:

```json
{ "type": "message", "data": { "body": "hello", "room_id": "roo_abc123" } }
```

Server responds with same envelope structure.

#### Protocol Types and Schema Generation

The WebSocket protocol is defined in `server/protocol/protocol.go` as the single source of truth. From this, we generate:

1. **JSON Schema** (`schema/protocol.json`) - Machine-readable API spec
2. **Zod schemas + TypeScript types** (`client/src/protocol.generated.ts`) - Runtime validation and static types

**Type generation pipeline:**
```
Go protocol types          JSON Schema              Zod schemas + TS types
(server/protocol/)    →    (schema/protocol.json)  →  (client/src/protocol.generated.ts)
     ↑                           ↑                            ↑
 Source of truth          `just schema`              `just client-types`
```

**Key files:**
- `server/protocol/protocol.go` - Define message types here with `jsonschema` struct tags
- `tools/schemagen/main.go` - Maintains the list of types to include in the schema
- `client/gen-types.mjs` - Generates Zod schemas and TypeScript types from JSON Schema

**Commands:**
```bash
just schema        # Generate JSON Schema only
just client-types  # Generate schema + Zod schemas + TypeScript types
```

**Runtime validation:** The frontend uses Zod to validate all incoming WebSocket messages at runtime. Use `parseServerEnvelope(raw)` which throws a `ZodError` if validation fails, or `safeParseServerEnvelope(raw)` which returns `null` on failure.

**Important:** When adding new message types, you must add them to **both**:
1. `server/protocol/protocol.go` - The type definition
2. `tools/schemagen/main.go` - The `types` slice that lists all types to export

#### Database Layer Organization

The database layer is split into two packages with distinct responsibilities:

##### `server/models/` - Generated Code (DO NOT EDIT)

- Contains dbtpl-generated code from `schema.sql`
- Files have `.dbtpl.go` suffix (e.g., `user.dbtpl.go`, `room.dbtpl.go`)
- Provides basic CRUD operations for database tables
- Also contains `generate_id.go` for ID generation helpers
- Regenerate with `just models` after schema changes

##### `server/db/` - Database Connection & Custom Queries

- `db.go` - Database connection wrapper with read/write separation
- Custom query functions that build on the generated models
- Examples: `IsRoomMember()`, `GetRoomMessages()`
- This is where you add business logic that requires custom SQL or combines multiple model operations

**When to use which:**
- Need basic insert/update/delete/select by ID? → Use `models` package directly
- Need custom SQL, joins, or complex queries? → Add to `db` package
- Need to check membership, fetch with pagination, etc.? → Add to `db` package

#### Database Models

- **DO NOT edit `*.dbtpl.go` files** - they are generated by dbtpl
- Schema changes go in `schema.sql`
- Run `just models` (or `bash tools/models.sh`) to regenerate
- Custom queries can be added to `tools/models.sh` using dbtpl's query mode
- Manual model extensions go in `server/db/` package

#### ID Generation

All IDs are prefixed strings for debuggability:

- Users: `usr_` + 16 hex chars
- Rooms: `roo_` + 12 hex chars
- Messages: `msg_` + 12 hex chars
- Sessions: base64-encoded random bytes

#### Database Access

- Use `db.QueryContext` / `db.QueryRowContext` for reads (uses read connection)
- Use `db.ExecContext` for writes (uses write connection with mutex)
- Always pass `context.Context` as first argument
- Timestamps stored as RFC3339 strings (RFC3339Nano for message timestamps)

#### Error Handling

- Use structured logging: `logger.Error("message", "key", value, "err", err)`
- Don't expose internal errors to clients
- Middleware recovers from panics and returns 500

#### Separation of Concerns

- `models/` - Database table representations, generated CRUD code (DO NOT EDIT)
- `db/` - Database connection + custom query functions
- `protocol/` - WebSocket protocol types (source of truth for API contract)
- `api/` - WebSocket message handling logic (uses protocol types directly)

### Frontend

#### DOM Helpers

Custom `$()` function for element creation:

```typescript
$(
  "div",
  { class: "message" },
  $("span", { text: username }),
  text(": "),
  $("span", { text: messageBody }),
);
```

#### WebSocket Client

- Single `Client` class manages WebSocket connection
- Messages are JSON with `{type, data}` structure
- Optimistic UI updates (show message immediately, don't wait for server)

#### Future Direction

- Keep close to web platform (Web Components when needed)
- Avoid frameworks; use modern browser APIs
- Prioritize backend API quality for alternative client support

## Development Workflow

### Running the Server

```bash
just run          # Build and run
modd              # Auto-rebuild on changes (install: go install github.com/cortesi/modd/cmd/modd)
```

### Building

```bash
just build        # Build both Go and JS
just build-go     # Go only
just build-js     # TypeScript only
```

### Database

```bash
just models       # Regenerate models from schema.sql
just browse-db    # Open database in Datasette
```

### Testing & Linting

```bash
just test         # Run linter, unit tests, and client tests (fast)
just test-all     # Run all tests including e2e (comprehensive)
just e2e          # Run only e2e tests
just lint         # Linter only
```

**Important**: `just lint` must pass before reporting work as complete. Fix all linting errors before finishing a task.

## Testing Strategy

The project has three levels of tests:

### Unit Tests

Test individual components in isolation (e.g., `hub_test.go`, `db_test.go`). These mock dependencies and run fast.

### Integration Tests

Located in `server/integration_test.go`. These spin up a real server with an in-memory database and test the full request lifecycle through real HTTP and WebSocket connections. See the file header for details on the test infrastructure.

To skip integration tests (if they become slow):

```bash
go test ./... -short
```

Integration tests check `testing.Short()` and skip themselves when `-short` is passed.

### End-to-End Tests (Playwright)

Located in `e2e/tests/`. These run a real browser against a real server and test user-facing behavior:

- **`auth.spec.ts`** - Registration, login, session persistence
- **`messaging.spec.ts`** - Sending messages, real-time delivery between users, message history
- **`rooms.spec.ts`** - Room switching, message scoping per room, URL updates

```bash
just e2e          # Run e2e tests (headless)
just e2e-headed   # Run with visible browser
just e2e-debug    # Run in debug mode (step through)
just e2e-ui       # Run with Playwright UI
```

E2E tests auto-start the server using `just run-e2e` which uses a fresh test database.

**Test helpers** in `e2e/tests/helpers.ts` provide utilities like `registerAndLogin()`, `sendMessage()`, `waitForMessage()`, and `switchToRoom()`.

**Note:** The WebSocket is exposed as `window.__ws` in the client for e2e test access (to send raw WebSocket messages for room creation, etc.).

### When to Update Tests

- **Bug fixes**: Add a test that reproduces the bug before fixing
- **New features**: Add both unit tests for new components and integration tests for user-facing behavior
- **User-facing changes**: Consider adding e2e tests for critical user flows
- **Refactors**: Existing tests should continue to pass; update them if interfaces change

## Pull Requests

When submitting a PR, export the session transcript using the `pr-transcript` skill:

```bash
./.pi/skills/pr-transcript/export-transcript.sh <pr-number> <description>
```

This saves an HTML transcript to `transcripts/` which should be committed with the PR.

## Key Design Decisions

1. **Single workspace**: No multi-tenancy; one deployment = one workspace
2. **SQLite**: Simple deployment, good enough for moderate scale
3. **Session-based auth**: Cookie-based sessions, no JWT
4. **Room-based access**: Users must be members of a room to see messages
5. **Real-time first**: WebSocket is primary API; REST/HTTP for auth only

## Adding New Features

### Adding a New WebSocket Message Type

1. Add the type definition in `server/protocol/protocol.go`:

```go
// MyNewRequest is sent by the client to do something
// Direction: client → server
type MyNewRequest struct {
    SomeField string `json:"some_field" jsonschema:"description=What this field does"`
}
```

2. Add the type to the generator list in `tools/schemagen/main.go`:

```go
types := []any{
    // ... existing types ...
    protocol.MyNewRequest{},  // Add new types here
}
```

3. Regenerate the schema and TypeScript types:

```bash
just client-types
```

4. Add handler in `server/api/`:

```go
func (a *Api) NewMessageType(user *models.User, msg json.RawMessage) ([]byte, error) {
    // Parse msg, validate, perform action, return response
}
```

5. Add case in `client.go` `readPump()` switch statement

6. Add client-side handler in `client/src/index.ts` using the generated types from `protocol.generated.ts`

### Adding a New Database Table

1. Add table definition to `schema.sql`
2. Run `just models`
3. Add any custom queries to `tools/models.sh` if needed
4. Create apimodels types if exposing to clients

### Adding Custom Database Queries

1. For simple queries that dbtpl can generate, add to `tools/models.sh`:
   ```bash
   go tool dbtpl query sqlite://dbtpl.db -M -B -2 -o server/models -T YourQueryName <<SQL
   SELECT ... FROM ... WHERE column = %%paramName paramType%%
   SQL
   ```

2. For complex queries needing conditional logic, add to `server/db/`:
   - Create a new file (e.g., `server/db/yourquery.go`)
   - Use the generated models and `*DB` type
   - Add tests in `server/db/yourquery_test.go`

### Adding a New HTTP Endpoint

1. Add handler method to `ChatServer` in `server/server.go`
2. Register route in `Run()` with appropriate middleware
3. Use `authRequired()` wrapper if authentication needed
